  $ rm -f *.nyo

  $ narya -v -parametric -direction p,rel,Br univalence.ny
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/isfibrant.ny
  
   ￫ info[I0000]
   ￮ constant isFibrant defined
  
   ￫ info[I0000]
   ￮ constant Fib defined
  
   ￫ info[I0000]
   ￮ constant Id𝕗 defined
  
   ￫ info[I0000]
   ￮ constant Idd𝕗 defined
  
   ￫ info[I0000]
   ￮ constant transport defined
  
   ￫ info[I0000]
   ￮ constant concat defined
  
   ￫ info[I0000]
   ￮ constant inverse defined
  
   ￫ info[I0000]
   ￮ constant transport2 defined
  
   ￫ info[I0000]
   ￮ constant refl_transport_1 defined
  
   ￫ info[I0000]
   ￮ constant refl_transport_2 defined
  
   ￫ info[I0000]
   ￮ constant Id𝕗2 defined
  
   ￫ info[I0000]
   ￮ constant concat_p1 defined
  
   ￫ info[I0000]
   ￮ constant J defined
  
   ￫ info[I0000]
   ￮ constant Sq𝕗 defined
  
   ￫ info[I0000]
   ￮ constant conn defined
  
   ￫ info[I0000]
   ￮ constant coconn defined
  
   ￫ info[I0000]
   ￮ constant concat_1p defined
  
   ￫ info[I0000]
   ￮ constant Jβ defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/isfibrant.ny (source)
  
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/bookhott.ny
  
   ￫ info[I0007]
   ￮ section eq opened
  
   ￫ info[I0000]
   ￮ constant eq defined
  
   ￫ info[I0000]
   ￮ constant cat defined
  
   ￫ info[I0000]
   ￮ constant cat3 defined
  
   ￫ info[I0000]
   ￮ constant idl defined
  
   ￫ info[I0000]
   ￮ constant inv defined
  
   ￫ info[I0000]
   ￮ constant ap defined
  
   ￫ info[I0000]
   ￮ constant ap_ap defined
  
   ￫ info[I0000]
   ￮ constant trr defined
  
   ￫ info[I0000]
   ￮ constant trr_ap defined
  
   ￫ info[I0000]
   ￮ constant trr2 defined
  
   ￫ info[I0000]
   ￮ constant trl2 defined
  
   ￫ info[I0000]
   ￮ constant trr2_ap defined
  
   ￫ info[I0000]
   ￮ constant whiskerR defined
  
   ￫ info[I0000]
   ￮ constant unwhiskerR defined
  
   ￫ info[I0008]
   ￮ section eq closed
  
   ￫ info[I0000]
   ￮ constant eq defined
  
   ￫ info[I0000]
   ￮ constant eqd defined
  
   ￫ info[I0000]
   ￮ constant ap2d defined
  
   ￫ info[I0000]
   ￮ constant eqdd defined
  
   ￫ info[I0000]
   ￮ constant ap3d defined
  
   ￫ info[I0007]
   ￮ section sq opened
  
   ￫ info[I0000]
   ￮ constant sq defined
  
   ￫ info[I0000]
   ￮ constant hrfl defined
  
   ￫ info[I0000]
   ￮ constant nat_toid defined
  
   ￫ info[I0000]
   ￮ constant ap defined
  
   ￫ info[I0000]
   ￮ constant act02 defined
  
   ￫ info[I0000]
   ￮ constant act20 defined
  
   ￫ info[I0000]
   ￮ constant to_cat defined
  
   ￫ info[I0000]
   ￮ constant to_cat3 defined
  
   ￫ info[I0000]
   ￮ constant all_rfl_21 defined
  
   ￫ info[I0000]
   ￮ constant unact21 defined
  
   ￫ info[I0000]
   ￮ constant cancel_12_eq_21 defined
  
   ￫ info[I0008]
   ￮ section sq closed
  
   ￫ info[I0000]
   ￮ constant sq defined
  
   ￫ info[I0000]
   ￮ constant selfnat defined
  
   ￫ info[I0000]
   ￮ constant eqv defined
  
   ￫ info[I0002]
   ￮ notation «_ ≅ _» defined
  
   ￫ info[I0000]
   ￮ constant fro_to_fro defined
  
   ￫ info[I0000]
   ￮ constant adjointify defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/bookhott.ny (source)
  
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/hott_bookhott.ny
  
   ￫ info[I0000]
   ￮ constant Id_eq defined
  
   ￫ info[I0000]
   ￮ constant Id_eqv defined
  
   ￫ info[I0000]
   ￮ constant 𝕗eqv defined
  
   ￫ info[I0000]
   ￮ constant sym_eqv defined
  
   ￫ info[I0000]
   ￮ constant 312_eqv defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/hott_bookhott.ny (source)
  
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/fibrant_types.ny
  
   ￫ info[I0000]
   ￮ constant ⊤ defined
  
   ￫ info[I0000]
   ￮ constant id_⊤_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗⊤ defined
  
   ￫ info[I0000]
   ￮ constant prod defined
  
   ￫ info[I0002]
   ￮ notation «_ × _» defined
  
   ￫ info[I0000]
   ￮ constant id_prod_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗prod defined
  
   ￫ info[I0000]
   ￮ constant Σ defined
  
   ￫ info[I0000]
   ￮ constant id_Σ_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗Σ defined
  
   ￫ info[I0000]
   ￮ constant Σ𝕗 defined
  
   ￫ info[I0000]
   ￮ constant Π defined
  
   ￫ info[I0000]
   ￮ constant id_Π_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗Π defined
  
   ￫ info[I0000]
   ￮ constant Π𝕗 defined
  
   ￫ info[I0000]
   ￮ constant ∅ defined
  
   ￫ info[I0000]
   ￮ constant 𝕗∅ defined
  
   ￫ info[I0000]
   ￮ constant Gel defined
  
   ￫ info[I0000]
   ￮ constant Gel_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗Gel defined
  
   ￫ info[I0000]
   ￮ constant sum defined
  
   ￫ info[I0002]
   ￮ notation «_ ⊔ _» defined
  
   ￫ info[I0000]
   ￮ constant sum_code defined
  
   ￫ info[I0000]
   ￮ constant id_sum_iso defined
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   239 |       (match u0, u1 [
   240 |        | left. a0, left. a1 ↦ 𝕗A.2 .id a0 a1
   241 |        | left. _, right. _ ↦ 𝕗∅
   242 |        | right. _, left. _ ↦ 𝕗∅
   243 |        | right. b0, right. b1 ↦ 𝕗B.2 .id b0 b1]))]
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ info[I0000]
   ￮ constant 𝕗sum defined
  
   ￫ info[I0000]
   ￮ constant ℕ defined
  
   ￫ info[I0000]
   ￮ constant ℕ_code defined
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   258 |        match n0, n1 [
   259 |        | zero., zero. ↦ zero.
   260 |        | zero., suc. n1 ↦ match m2 [ ]
   261 |        | suc. n0, zero. ↦ match m2 [ ]
   262 |        | suc. n0, suc. n1 ↦ suc. (id_ℕ_iso n0 n1 .to m2)])
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   263 |       ([ zero. ⤇ () | suc. m ⤇ id_ℕ_iso m.0 m.1 .fro m.2 ])
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   265 |        match n0, n1 [
   266 |        | zero., zero. ↦ rfl.
   267 |        | zero., suc. n1 ↦ match m2 [ ]
   268 |        | suc. n0, zero. ↦ match m2 [ ]
   269 |        | suc. n0, suc. n1 ↦ id_ℕ_iso n0 n1 .fro_to m2])
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_types.ny
   270 |       ([ zero. ⤇ rfl.
   271 |        | suc. m ⤇
   272 |            eq.ap (Br ℕ m.0 m.1) (Br ℕ (suc. m.0) (suc. m.1)) (x ↦ suc. x)
   273 |              (id_ℕ_iso m.0 m.1 .to (id_ℕ_iso m.0 m.1 .fro m.2)) m.2
   274 |              (id_ℕ_iso m.0 m.1 .to_fro m.2)])
       ^ match encountered outside case tree, wrapping in implicit let-binding
  
   ￫ info[I0000]
   ￮ constant id_ℕ_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗_ℕ_code defined
  
   ￫ info[I0000]
   ￮ constant 𝕗ℕ defined
  
   ￫ info[I0001]
   ￮ axiom funext assumed
  
   ￫ info[I0000]
   ￮ constant funext_refl defined
  
   ￫ info[I0007]
   ￮ section Indexed_𝕎 opened
  
   ￫ info[I0000]
   ￮ constant 𝕎spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕎 defined
  
   ￫ info[I0000]
   ￮ constant code_spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode_decode defined
  
   ￫ info[I0000]
   ￮ constant id_𝕎_iso defined
  
   ￫ info[I0008]
   ￮ section Indexed_𝕎 closed
  
   ￫ info[I0000]
   ￮ constant 𝕎 defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_code defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode_decode defined
  
   ￫ info[I0000]
   ￮ constant Id_𝕎_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗_𝕎_code defined
  
   ￫ info[I0000]
   ￮ constant 𝕗𝕎 defined
  
   ￫ info[I0007]
   ￮ section Parametrized_W opened
  
   ￫ info[I0000]
   ￮ constant 𝕎_spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕎 defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_proj1 defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_proj2 defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_code_spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_decode_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕎_encode_decode defined
  
   ￫ info[I0000]
   ￮ constant Id_𝕎_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗𝕎 defined
  
   ￫ info[I0008]
   ￮ section Parametrized_W closed
  
   ￫ info[I0000]
   ￮ constant 𝕄_spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕄 defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_code_spec defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_encode defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_decode defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_bisim defined
  
   ￫ info[I0001]
   ￮ axiom 𝕄_ext assumed
  
   ￫ info[I0000]
   ￮ constant 𝕄_encode_decode_bisim defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_encode_decode defined
  
   ￫ info[I0000]
   ￮ constant refl_𝕄_bisim defined
  
   ￫ info[I0001]
   ￮ axiom refl_𝕄_ext assumed
  
   ￫ info[I0000]
   ￮ constant 𝕄_decode_encode_bisim defined
  
   ￫ info[I0000]
   ￮ constant 𝕄_decode_encode defined
  
   ￫ info[I0000]
   ￮ constant Id_𝕄_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗𝕄 defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/fibrant_types.ny (source)
  
   ￫ info[I0003]
   ￮ loading file: $TESTCASE_ROOT/homotopy.ny
  
   ￫ info[I0000]
   ￮ constant isContr defined
  
   ￫ info[I0000]
   ￮ constant iscontr_idfrom defined
  
   ￫ info[I0000]
   ￮ constant iscontr_idto defined
  
   ￫ info[I0000]
   ￮ constant is11 defined
  
   ￫ info[I0000]
   ￮ constant is11_Id defined
  
   ￫ info[I0000]
   ￮ constant isBisim defined
  
   ￫ info[I0000]
   ￮ constant bisim_of_11 defined
  
   ￫ info[I0000]
   ￮ constant isbisim_eqv defined
  
   ￫ info[I0000]
   ￮ constant bisim_of_Id defined
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/homotopy.ny (source)
  
   ￫ info[I0000]
   ￮ constant pre_univalence defined
  
   ￫ info[I0000]
   ￮ constant univalence_bisim defined
  
   ￫ info[I0000]
   ￮ constant univalence_11 defined
  
   ￫ info[I0000]
   ￮ constant is11_Id𝕗 defined
  
   ￫ info[I0000]
   ￮ constant srefl defined
  
   ￫ info[I0000]
   ￮ constant srefl_is_strict defined
  
   ￫ info[I0000]
   ￮ constant univalence_vv defined
  
   ￫ info[I0000]
   ￮ constant univalence_is_left_definitional defined
  
   ￫ info[I0000]
   ￮ constant univalence_is_right_definitional defined
  

  $ narya -v -parametric -direction p,rel,Br univalence_ee.ny
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/isfibrant.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/bookhott.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/hott_bookhott.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/fibrant_types.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/homotopy.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/univalence.ny (compiled)
  
   ￫ info[I0000]
   ￮ constant isBisim_ee defined
  
   ￫ info[I0000]
   ￮ constant isbisim_ee_eqv defined
  
   ￫ info[I0000]
   ￮ constant pre_univalence_ee defined
  
   ￫ info[I0000]
   ￮ constant Gel_ee defined
  
   ￫ info[I0000]
   ￮ constant Gel_ee_iso defined
  
   ￫ info[I0000]
   ￮ constant 𝕗Gel_ee defined
  
   ￫ info[I0000]
   ￮ constant univalence_ee defined
  

  $ narya -parametric -direction p,rel,Br 2dpitr.ny
  B22 (A22 .f .liftl.1 a12) .f .trr.1 (f02 (A22 .f .trl.1 a12))
    : B12 a12
    .t (B20 (A20 .f .liftl a10) .f .trr (f00 (A20 .f .trl a10)))
      (B21 (A21 .f .liftl a11) .f .trr (f01 (A21 .f .trl a11)))
  
  B22 (A22 .f .id.1 (A02 .f .liftl a01) (A12 .f .liftl a11) .liftl a21)
    .f
    .id.1 (f02 (A02 .f .liftl a01)) (f12 (A12 .f .liftl a11))
    .trr
      (f20 (A22 .f .id.1 (A02 .f .liftl a01) (A12 .f .liftl a11) .trl a21))
    : B21 a21 .t (f01 a01) (f11 a11)
  
  B22 (A22 .f .id.1 (A02 .f .liftl a01) (A12 .f .liftl a11) .liftl a21)
    .f
    .id.1 (f02 (A02 .f .liftl a01)) (f12 (A12 .f .liftl a11))
    .trr
      (f20 (A22 .f .id.1 (A02 .f .liftl a01) (A12 .f .liftl a11) .trl a21))
    : B21 a21 .t (f01 a01) (f11 a11)
  
  A22 .f .id.1 (A02 .f .liftl a01) (A12 .f .liftl a11) .trl a21
    : A20 .t (A02 .f .trl a01) (A12 .f .trl a11)
  
  sym A22 .f .trl.1 a21
    : A20 .t (A02 .f .trl a01) (A12 .f .trl a11)
  
  A22 .f .id.1 (A02 .f .liftl a01) (A12 .f .liftl a11) .liftl a21
    : A22 .t (A02 .f .liftl a01) (A12 .f .liftl a11)
        (A22 .f .id.1 (A02 .f .liftl a01) (A12 .f .liftl a11) .trl a21) a21
  
  sym (sym A22 .f .liftl.1 a21)
    : A22 .t (A02 .f .liftl a01) (A12 .f .liftl a11) (sym A22 .f .trl.1 a21)
        a21
  
  B22 (sym (sym A22 .f .liftl.1 a21))
    .f
    .id.1 (f02 (A02 .f .liftl a01)) (f12 (A12 .f .liftl a11))
    .trr (f20 (sym A22 .f .trl.1 a21))
    : B21 a21 .t (f01 a01) (f11 a11)
  
  sym B22 (sym A22 .f .liftl.1 a21) .f .trr.1 (f20 (sym A22 .f .trl.1 a21))
    : B21 a21
    .t (B02 (A02 .f .liftl a01) .f .trr (f00 (A02 .f .trl a01)))
      (B12 (A12 .f .liftl a11) .f .trr (f10 (A12 .f .trl a11)))
  
  $ narya -v -parametric -direction p,rel,Br fibrant_sqrt.ny
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/isfibrant.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/bookhott.ny (compiled)
  
   ￫ info[I0004]
   ￮ file loaded: $TESTCASE_ROOT/hott_bookhott.ny (compiled)
  
   ￫ info[I0007]
   ￮ section single opened
  
   ￫ info[I0001]
   ￮ axiom A assumed
  
   ￫ info[I0001]
   ￮ axiom 𝕗A assumed
  
   ￫ info[I0000]
   ￮ constant √A× defined
  
   ￫ info[I0000]
   ￮ constant √IdA× defined
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_sqrt.ny
   31 |          [ .root.p ↦ y2.2 .root | .root.1 ↦ y2 .root1 | .else ↦ y2 .else ])
      ^ comatch encountered outside case tree, wrapping in implicit let-binding
  
   ￫ hint[H0403]
   ￭ $TESTCASE_ROOT/fibrant_sqrt.ny
   33 |          [ .root.p ↦ x2.2 .root.2 | .root1 ↦ x2 .root | .else ↦ x2 .else ])
      ^ comatch encountered outside case tree, wrapping in implicit let-binding
  
   ￫ info[I0000]
   ￮ constant id√_iso defined, containing 2 holes
  
   ￫ info[I3003]
   ￮ hole ?0:
     
     B0 : Type
     B1 : Type
     B2 : Type⁽ᵖ⁾ B0 B1
     x0 : √A× B0
     x1 : √A× B1
     y2 : √IdA× B0 B1 B2 x0 x1
     ----------------------------------------------------------------------
     eq.eq (√IdA× B0 B1 B2 x0 x1) _comatch.F0.1{…} y2
  
   ￫ info[I3003]
   ￮ hole ?1:
     
     B0 : Type
     B1 : Type
     B2 : Type⁽ᵖ⁾ B0 B1
     x0 : √A× B0
     x1 : √A× B1
     x2 : √A×⁽ᵖ⁾ B2 x0 x1
     ----------------------------------------------------------------------
     eq.eq (√A×⁽ᵖ⁾ B2 x0 x1) _comatch.F0.0{…} x2
  
   ￫ info[I0000]
   ￮ constant 𝕗√A× defined, containing 1 hole
  
   ￫ info[I3003]
   ￮ hole ?2:
     
     B.0 : Type
     B.1 : Type
     B.2 : Type⁽ᵖ⁾ B.0 B.1
     𝕗B.0 : isFibrant B.0
     𝕗B.1 : isFibrant B.1
     𝕗B.2 : isFibrant⁽ᵖ⁾ B.2 𝕗B.0 𝕗B.1
     x0 : √A× B.0
     x1 : √A× B.1
     ----------------------------------------------------------------------
     isFibrant (√IdA× B.0 B.1 B.2 x0 x1)
  
   ￫ info[I0008]
   ￮ section single closed
  
   ￫ info[I0007]
   ￮ section parametrized opened
  
   ￫ info[I0001]
   ￮ axiom Γ assumed
  
   ￫ info[I0001]
   ￮ axiom 𝕗Γ assumed
  
   ￫ info[I0001]
   ￮ axiom A assumed
  
   ￫ info[I0001]
   ￮ axiom 𝕗A assumed
  
   ￫ info[I0000]
   ￮ constant √A defined
  
   ￫ info[I0000]
   ￮ constant 𝕗√A defined, containing 1 hole
  
   ￫ info[I3003]
   ￮ hole ?3:
     
     x.0 : Γ
     x.1 : Γ
     x.2 : Br Γ x.0 x.1
     a₀ : √A x.0
     a₁ : √A x.1
     ----------------------------------------------------------------------
     isFibrant (√A⁽ᵖ⁾ x.2 a₀ a₁)
  
   ￫ info[I0008]
   ￮ section parametrized closed
  
   ￫ error[E3002]
   ￮ file fibrant_sqrt.ny contains open holes
  
  [1]
